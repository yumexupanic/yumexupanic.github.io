<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 ThreadLocal 存储用户信息</title>
      <link href="/2023/11/21/threadlocal-store-user-info/"/>
      <url>/2023/11/21/threadlocal-store-user-info/</url>
      
        <content type="html"><![CDATA[<p>由于目前的 web 应用，几乎都是线程多路复用，同一时间的用户请求都在独立的线程中。所以可以把用户信息存储在 ThreadLocal 中，减少引用对象的传递。</p><h2 id="实现-UserContext"><a href="#实现-UserContext" class="headerlink" title="实现 UserContext"></a>实现 UserContext</h2><pre><code class="java">public class UserContext &#123;    private static final ThreadLocal&lt;User&gt; local = new ThreadLocal&lt;User&gt;();    public static void set(User user)&#123;        local.set(user);    &#125;    public static User get()&#123;        return local.get();    &#125;    public static void remove()&#123;        local.remove();    &#125;&#125;</code></pre><h2 id="获取授权信息并设置"><a href="#获取授权信息并设置" class="headerlink" title="获取授权信息并设置"></a>获取授权信息并设置</h2><pre><code class="java">var token = request.getHeader(&quot;Authorization&quot;);var user = getUser(token);UserContext.set(user);</code></pre><h2 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h2><p>在 http 返回之前，移除用户数据</p><pre><code class="java">UserContext.remove();</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开源低代码引擎 Yao 体验</title>
      <link href="/2023/05/24/yao-engine/"/>
      <url>/2023/05/24/yao-engine/</url>
      
        <content type="html"><![CDATA[<p>从生成式 ai 出来之后，低代码的热潮又被带动了一波。低代码可以实现少写代码，或者不写代码的方式来搭建一个稳定可用的系统。对于企业而言减少开发成本。</p><p>但是对于我自己来说，不怕难，但怕烦。公司内部业务系统较多，如果都要自己实现 也未免太麻烦了一点，人生苦短。应该把时间放在更有意义的事情上。</p><p>最近公司内部需要一个业务平台，来记录和统计一些数据，刚好借着这个机会，去了解一下。</p><span id="more"></span><p>我的需求比较明确：</p><ul><li>只考虑开源项目</li><li>部署简单</li><li>完善的鉴权体系</li></ul><p>最终我找到了一个用 golang 实现的开源低代码引擎 yao，为什么说这是一个引擎，而不是一个低代码框架或者平台？因为这个并不是像 illacloud 那样的 sass 平台。它的实现方式比较特别，总的来说是利用 json 做的 DSL，从界面到数据处理 都是通过 json 来配置的，除了自定义脚本，脚本是通过 javascript 实现的。</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/202305241606956.png"></p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>确定了开源项目之后，花了一天的时间看了 yao 引擎官方的几个 demo 后，我就开始上手了。不过越写到后面，越发现 DSL 学习成本有点高。主要官方的文档没有及时更新，文档和 demo 里面的代码有些地方差距较大。这里浪费了一些时间，最终我是 fork 了一份代码到本地。看着 golang 里面的 DSL 定义来配置 json。</p><h3 id="登陆信息获取"><a href="#登陆信息获取" class="headerlink" title="登陆信息获取"></a>登陆信息获取</h3><p>yao 引擎的登陆系统存在两个逻辑，一个是平台自己的账号，一个是业务自己的账号。平台的账号可以叫做 admin，业务的账号叫做 user，这是两个不同的路由。这里会有一个问题，系统账号和业务账号登录进去后，页面是一样的，并不能控制权限，只能控制数据（当然这个过程也比较麻烦，后面会写出）。</p><p>所以我这里是管理员登陆逻辑和业务登陆逻辑保持一致。把 logins 文件夹下面的 两个文件内容保持一致即可</p><ul><li>logins&#x2F;user.login.json</li><li>logins&#x2F;admin.login.json</li></ul><p>上面说到的是一些小问题，无伤大雅。最关键的问题是登陆信息获取这个地方有 bug，用户登陆完毕之后，一个完整的业务系统是需要获取到用户信息的。这个引擎虽然实现了 session 相关的操作 process，但是并不怎么好用。设置了之后取出是空的。</p><pre><code class="jsx">let sid = Process(&quot;session.Start&quot;);let jwt = Process(  &quot;xiang.helper.JwtMake&quot;,  user.id,  &#123;    id: user.id,    role: user.role,    staff_name: user.staff_name,    dept_id: user.dept_id,  &#125;,  &#123; timeout: 30 * 24 * 60 * 60, sid: sid &#125;);delete user.password;//关键代码Process(&quot;session.Set&quot;, &quot;user&quot;, user, 30 * 24 * 60 * 60);</code></pre><p>这里是处理用户登陆的核心代码，在校验完毕账号和密码之后，需要创建 token（jwt）有效期设置为30天，然后给到 session 当中。</p><p>这段代码比较简单，在登陆之后把用户数据存储到 session 中应该就可以了。但是我在后面到步骤中，一直无法获取到数据，为空。</p><pre><code class="jsx">let user = Process(&quot;session.Get&quot;, &quot;user&quot;);// user: null</code></pre><p>这里浪费了大量的时间之后，我换了一种实现方式。看见 yao 引擎有一个 store 存储的 process，相当于存储数据到内存中。 那么我把用户登陆的数据和 session id 存储到内存中不就可以了，相当于一个 map。</p><pre><code class="jsx">let sid = Process(&quot;session.Start&quot;);new Store(&quot;cache&quot;).Set(sid, user);</code></pre><pre><code class="jsx">//获取let user = new Store(&quot;cache&quot;).Get(Process(&quot;session.ID&quot;), &quot;user&quot;);//&#123;id: xxx,name:xxx&#125;</code></pre><aside>💡 这里也有一个坑，后面会说到</aside><h3 id="数据权限控制"><a href="#数据权限控制" class="headerlink" title="数据权限控制"></a>数据权限控制</h3><p>一个业务系统，根据用户的权限来显示不同的数据是一个很常见的需求，这里介绍下方法。</p><p>这是默认表格使用的 process</p><pre><code class="java">Process(&quot;models.user.Paginate&quot;, param, 1, 1000)</code></pre><p>如果我们要自定义数据查询方式，这里有三种方式。</p><p><strong>使用 DSL 语法增加查询条件</strong></p><pre><code class="java">&quot;search&quot;: &#123;  &quot;default&quot;: [    &#123;      &quot;orders&quot;: [&#123; &quot;column&quot;: &quot;event_date&quot;, &quot;option&quot;: &quot;desc&quot; &#125;],      &quot;user_id[]&quot;: []    &#125;  ]&#125;</code></pre><p>这种方式一般来说，是首选的方式。但是我并不推荐这样用，首先是但是官网文档晦涩难懂，并没有给出更多的例子 以上只是做了一个默认的排序操作我找文档都找了很久，最终还是在 demo 中看到这种写法 。另外这种方式并不能设置查询条件默认值，可能是通过 querystring 来控制。但是 querystring 我们无法控制，是系统内部的路由处理的。</p><p><strong>使用 <code>after:search</code></strong> </p><pre><code class="jsx">// 先配置 DSL &quot;after:search&quot;: &quot;scripts.user.AfterSearch&quot;function AfterSearch(data) &#123;    //获取用户权限     let user = new Store(&quot;cache&quot;).Get(Process(&quot;session.ID&quot;), &quot;user&quot;);    if(user.role == &#39;normal&#39;) &#123;        //修改 data    &#125;  return data;&#125;</code></pre><p>使用 hook 函数修改返回的数据，但是这种方式会导致分页信息异常。不推荐</p><p><strong>重写查询接口</strong></p><pre><code class="jsx">&quot;search&quot;: &#123;  &quot;guard&quot;: &quot;bearer-jwt,scripts.user.Guard&quot;,  &quot;process&quot;: &quot;scripts.wakatime.Search&quot;,  &quot;default&quot;: [    &#123;      &quot;orders&quot;: [&#123; &quot;column&quot;: &quot;event_date&quot;, &quot;option&quot;: &quot;desc&quot; &#125;],      &quot;user_id[]&quot;: []    &#125;  ]&#125;</code></pre><p>能看到这一部分的 DSL 多了一些内容，其中最关键的是 <code>process</code> ，这里定义了我们处理查询的 process 相关实现如下: </p><pre><code class="jsx">function Search(param, page, pageSize) &#123;  let user = new Store(&quot;cache&quot;).Get(Process(&quot;session.ID&quot;), &quot;user&quot;);  if (param.wheres) &#123;    if (user.role == &quot;管理员&quot;) &#123;      var query = new Query();      let users = query.Get(&#123;        select: [&quot;id&quot;],        wheres: [          &#123; &quot;:deleted_at&quot;: &quot;删除&quot;, &quot;=&quot;: null &#125;,          &#123; field: &quot;dept_id&quot;, op: &quot;=&quot;, value: user.dept_id &#125;,        ],        from: &quot;e_user&quot;,      &#125;);      let userid = users.map((e) =&gt; e.id);      param.wheres.push(&#123;        column: &quot;user_id&quot;,        op: &quot;in&quot;,        value: userid,      &#125;);    &#125; else &#123;      param.wheres.push(&#123; column: &quot;user_id&quot;, value: user.id &#125;);    &#125;  &#125;  var data = Process(    &quot;models.wakatime.Paginate&quot;,    &#123;      ...param,    &#125;,    page,    pageSize  );  return data;&#125;</code></pre><p>要让这段脚本正常的执行，还需要一个关键的参数，也就是在 DSL 中的这段代码:</p><pre><code class="jsx">  &quot;guard&quot;: &quot;bearer-jwt,scripts.user.Guard&quot;,</code></pre><p>由于登录信息无法获取，我这里使用的是会话缓存的方式实现。这里的意思是增加了一个中间件，<code>bearer-jwt</code> 是系统默认的，第二个是<code>scripts.user.Guard</code> 这是自定义的授权，相关实现如下:</p><pre><code class="jsx">function Guard(path, params, query, payload, headers) &#123;  let token = headers.Authorization[0];  let data = Process(&quot;xiang.helper.JwtValidate&quot;, token.replace(&quot;Bearer &quot;, &quot;&quot;));  let sid = Process(&quot;session.ID&quot;);  new Store(&quot;cache&quot;).Set(sid, data.data);&#125;</code></pre><p>那么每一次获取列表之前，都会先到我这个中间件来，这里会处理 http 请求中携带的授权信息，根据授权信息取出用户信息存储在会话缓存中。</p><p>那么为什么这一步不能写在 <code>scripts.wakatime.Search</code> 中？我也想这么干，但是在查询 process 中无法获取到 token header。所以只能写一个中间件在查询之前先把用户信息获取到，然后在查询脚本中 根据会话 ID 获取用户信息。</p><aside>💡 也就是说，如果有任何需要控制数据权限的地方，中间件是必须增加的，否则无法获取到用户信息。</aside><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>这个引擎并不能满足我的需求，小问题有点多， 系统并不能正常使用的，起初我加了他们的群，问了下开发人员，并不能很好解决问题，比如</p><ol><li>Select 默认缓存了，只有在开发环境中才不会缓存</li><li>Select 无法搜索</li><li>只能导出数据库中的记录，不能进行数据处理</li><li>统计图 饼图显示的数值不是总计，而是最后一条数据的值</li><li>无法去掉登录验证码</li><li>弹窗保存事件有时候会触发很多次</li></ol><p>前面两个 Select 的问题 0.10.3 pre 已经解决了，后面我更新了下源码，准备自己修改后面几个问题 ，源码是基于 0.10.3 pre 版本。</p><p>yao 引擎主要的核心库有以下几个 </p><ul><li>yao</li><li>v8go</li><li>xun</li><li>kun</li><li>xgen</li><li>gou</li></ul><p>我这次需要修改的主要是 yao 和 xgen 前面是 yao 核心库，xgen 基于 react 实现的前端页面。 </p><h3 id="自定义导出"><a href="#自定义导出" class="headerlink" title="自定义导出"></a>自定义导出</h3><p>看了下官方的导出实现，只能导出 table 数据。我想先从数据库中统计一些数据，然后再导出，并且会增加一些颜色标记等。</p><blockquote><p>导出流程是先触发脚本，生成 excel 文件并放入指定的目录，然后通过 http 请求去下载文件。</p></blockquote><p><strong>新建文件</strong> </p><p>helper&#x2F;excel.go</p><pre><code class="go">package helperimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;github.com/google/uuid&quot;    &quot;github.com/xuri/excelize/v2&quot;    &quot;github.com/yaoapp/gou&quot;    &quot;github.com/yaoapp/yao/config&quot;    &quot;path/filepath&quot;)type Payload struct &#123;    Columns []struct &#123;        Name string `json:&quot;name&quot;`    &#125; `json:&quot;columns&quot;`    Data    [][]string `json:&quot;data&quot;`    Options struct &#123;        TitleRow   int    `json:&quot;titleRow&quot;`        ColWidth   int    `json:&quot;colWidth&quot;`        OtherStyle string `json:&quot;otherStyle&quot;&quot;`        HeadStyle  string `json:&quot;headStyle&quot;&quot;`        BodyStyle  string `json:&quot;bodyStyle&quot;&quot;`    &#125; `json:&quot;options&quot;`&#125;func ProcessExcel(process *gou.Process) interface&#123;&#125; &#123;    process.ValidateArgNums(0)    body := Payload&#123;&#125;    json.Unmarshal([]byte(process.ArgsString(0)), &amp;body)    fmt.Println(body.Options.BodyStyle)    // 创建一个新的工作簿    f := excelize.NewFile()    // 创建一个工作表    sheetName := &quot;Sheet1&quot;    var titleStyle = -1    var bodyStyle = -1    var otherStyle = -1    if len(body.Options.HeadStyle) &gt; 0 &#123;        titleStyle, _ = f.NewStyle(body.Options.HeadStyle)    &#125;    if len(body.Options.BodyStyle) &gt; 0 &#123;        bodyStyle, _ = f.NewStyle(body.Options.BodyStyle)    &#125;    if len(body.Options.OtherStyle) &gt; 0 &#123;        otherStyle, _ = f.NewStyle(body.Options.OtherStyle)    &#125;    var titleRow []string    for _, column := range body.Columns &#123;        titleRow = append(titleRow, column.Name)    &#125;    for i, v := range titleRow &#123;        cellName, _ := excelize.CoordinatesToCellName(i+1, body.Options.TitleRow)        f.SetCellValue(sheetName, cellName, v)        if titleStyle &gt; -1 &#123;            f.SetCellStyle(sheetName, cellName, cellName, titleStyle)        &#125;    &#125;    if body.Options.TitleRow &gt; 1 &amp;&amp; otherStyle &gt; -1 &#123;        for i := 0; i &lt; body.Options.TitleRow; i++ &#123;            for col, _ := range titleRow &#123;                cellName, _ := excelize.CoordinatesToCellName(col+1, i)                f.SetCellStyle(sheetName, cellName, cellName, otherStyle)            &#125;        &#125;    &#125;    numRow := body.Options.TitleRow + 1    for i, dataRow := range body.Data &#123;        rowNum := i + numRow // 数据行        for index, v := range dataRow &#123;            cellName, _ := excelize.CoordinatesToCellName(index+1, rowNum)            f.SetCellValue(sheetName, cellName, v)            if bodyStyle &gt; -1 &#123;                f.SetCellStyle(sheetName, cellName, cellName, bodyStyle)            &#125;        &#125;    &#125;    if body.Options.ColWidth &gt; 0 &#123;        for i := 1; i &lt;= len(body.Data); i++ &#123;            colName, _ := excelize.ColumnNumberToName(i)            err := f.SetColWidth(&quot;Sheet1&quot;, colName, colName, float64(body.Options.ColWidth))            if err != nil &#123;                fmt.Println(err)            &#125;        &#125;    &#125;    uuid, _ := uuid.NewRandom()    filename := fmt.Sprintf(&quot;%s.xlsx&quot;, uuid.String())    path := filepath.Join(filepath.Join(config.Conf.Root, &quot;data&quot;), filename)    fmt.Println(path)    // 保存工作簿    if err := f.SaveAs(path); err != nil &#123;        fmt.Println(err)    &#125;    return filename&#125;</code></pre><p><strong>注册到处理器</strong></p><p>helper&#x2F;process.go</p><pre><code class="go">//Excel 处理器gou.RegisterProcessHandler(&quot;utils.biz.excel&quot;, ProcessExcel)</code></pre><p><strong>使用</strong></p><pre><code class="go">//payload 就是我需要导出的业务数据 Process(&quot;utils.biz.excel&quot;, JSON.stringify(payload))</code></pre><p><strong>效果</strong></p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/202305241608869.png"></p><h3 id="增加中文转拼音"><a href="#增加中文转拼音" class="headerlink" title="增加中文转拼音"></a>增加中文转拼音</h3><p>业务需要支持拼音搜索数据，js 汉字转音频需要安装一些库，v8go 是不支持的，所以可以新增一个处理器来做这件事情。</p><p><strong>新增文件</strong></p><p>helper&#x2F;pinyin.go</p><pre><code class="go">package helperimport (    &quot;github.com/mozillazg/go-pinyin&quot;    &quot;github.com/yaoapp/gou&quot;)func ProcessPinYin(process *gou.Process) interface&#123;&#125; &#123;    process.ValidateArgNums(1)    hans := process.ArgsString(0)    args := pinyin.NewArgs()    return pinyin.LazyPinyin(hans, args)&#125;</code></pre><p><strong>注册处理器</strong></p><pre><code class="go">//自定义增加的处理器gou.RegisterProcessHandler(&quot;utils.biz.pinyin&quot;, ProcessPinYin)</code></pre><p><strong>使用</strong></p><pre><code class="jsx">function save(payload)&#123;    let py = Process(&quot;utils.biz.pinyin&quot;, payload.project_name);  payload.pinyin_key = py.join(&quot;&quot;);  let result = Process(&quot;models.project.save&quot;, payload);&#125;</code></pre><h3 id="解决统计图-NumbearChart-值错误"><a href="#解决统计图-NumbearChart-值错误" class="headerlink" title="解决统计图 NumbearChart 值错误"></a>解决统计图 NumbearChart 值错误</h3><p>这里的值应该是累加的合，而不是最后一个数据的值</p><p>修改文件： xgen&#x2F;components&#x2F;chart&#x2F;NumberChart&#x2F;index.tsx</p><pre><code class="jsx">const total = props.data.map((e) =&gt; e[props.valueKey || &#39;value&#39;]).reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0)&lt;BaseNumber &#123;...props&#125; number=&#123;total&#125;&gt;&lt;/BaseNumber&gt;</code></pre><p><strong>效果</strong></p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/202305241608770.png"></p><p>左边的时间之前是最后一条数据的值。</p><h3 id="新窗口打开后-token-消失"><a href="#新窗口打开后-token-消失" class="headerlink" title="新窗口打开后 token 消失"></a>新窗口打开后 token 消失</h3><p>在同一个浏览器上，登录成功之后 复制地址重新打开 tab 会发现 token 失效。具体的原因我没有去查，为了快速解决问题，我这里使用了 localStorage 来存储 token，修改了 token 相关逻辑。这个问题算是暂时解决了。</p><h3 id="Select-远程搜索太慢"><a href="#Select-远程搜索太慢" class="headerlink" title="Select 远程搜索太慢"></a>Select 远程搜索太慢</h3><p>这里官方用了一个抖动函数，但是对于我来说 这里有点太慢了，打完字之后要等个一段时间才出结果。</p><p>修改源码: xgen&#x2F;components&#x2F;edit&#x2F;Select&#x2F;model.ts</p><pre><code class="jsx">//line 30 这里之前是等待了 800 mstarget[&#39;onSearch&#39;] = debounce(this.remote.searchOptions, 100, &#123; leading: true &#125;)</code></pre><h3 id="去掉业务助手和登录验证码"><a href="#去掉业务助手和登录验证码" class="headerlink" title="去掉业务助手和登录验证码"></a>去掉业务助手和登录验证码</h3><p>在 0.10.3 pre 版本中，自带了业务助手，当时还没有正式发布，但是业务并不需要这个东西，暂时无法关闭，我只有把这个入口给删除了。</p><p>修改文件: xgen&#x2F;packages&#x2F;xgen&#x2F;layouts&#x2F;index.tsx</p><pre><code class="jsx">这里把 Neo 业务助手注释即可&#123;/* &lt;Neo &#123;...props_neo&#125;&gt;&lt;/Neo&gt; */&#125;</code></pre><p>登录验证码的移除需要修改两个地方，一处是验证器，一处是表单，但是改动有4个文件 。 </p><p>修改文件: </p><p>xgen&#x2F;packages&#x2F;xgen&#x2F;pages&#x2F;login&#x2F;model.ts</p><pre><code class="jsx">// line 48async afterLogin(res: ResLogin, err: Utils.ResError) &#123;        if (err || !res?.token) &#123;            this.loading.login = false            // this.getCaptcha()            return        &#125;    ...&#125;//line 93onFinish(data: FormValues) &#123;        const &#123; mobile, password, code &#125; = data        const is_email = mobile.indexOf(&#39;@&#39;) !== -1        if (is_email) &#123;            if (!reg_email.test(mobile)) &#123;                return message.warning(this.global.locale_messages.login.form.validate.email)            &#125;        &#125; else &#123;            if (!reg_mobile.test(mobile)) &#123;                return message.warning(this.global.locale_messages.login.form.validate.mobile)            &#125;        &#125;        // captcha: &#123;        // id: this.captcha.id,        // code        // &#125;,        this.login(&#123;            [is_email ? &#39;email&#39; : &#39;mobile&#39;]: mobile,            password: password,            sid: local.temp_sid,            ...(this.is ? &#123; is: this.is &#125; : &#123;&#125;)        &#125;)    &#125;</code></pre><p>修改文件: xgen&#x2F;packages&#x2F;xgen&#x2F;pages&#x2F;login&#x2F;types.ts</p><pre><code class="jsx">// line 17export interface ReqLogin &#123;    email?: string    mobile?: string    is?: string    sid: string    password: string    // captcha: &#123;    // id: string    // code: string    // &#125;&#125;</code></pre><p>修改文件: xgen&#x2F;packages&#x2F;xgen&#x2F;pages&#x2F;login&#x2F;admin&#x2F;index.tsx</p><pre><code class="jsx">// line 9const Index = () =&gt; &#123;    const [x] = useState(() =&gt; container.resolve(Model))    useAsyncEffect(async () =&gt; &#123;        await window.$app.Event.emit(&#39;app/getAppInfo&#39;)        x.user_type = &#39;admin&#39;        // x.getCaptcha()    &#125;, [])    return &lt;Common type=&#39;admin&#39; x=&#123;x&#125;&gt;&lt;/Common&gt;&#125;</code></pre><p>修改文件: xgen&#x2F;packages&#x2F;xgen&#x2F;pages&#x2F;login&#x2F;components&#x2F;Common&#x2F;components&#x2F;Form.tsx</p><pre><code class="jsx">//line 91&lt;Item noStyle shouldUpdate&gt;    &#123;() =&gt; (    &lt;Button        className=&#123;clsx([            &#39;btn_login&#39;,            !(                (getFieldValue(&#39;mobile&#39;) &amp;&amp; getFieldValue(&#39;password&#39;))                //&amp;&amp; getFieldValue(&#39;code&#39;)            ) &amp;&amp; &#39;disabled&#39;        ])&#125;        type=&#39;primary&#39;        htmlType=&#39;submit&#39;        shape=&#39;round&#39;        loading=&#123;loading&#125;    &gt;        &#123;messages.login.title&#125;    &lt;/Button&gt;)&#125;&lt;/Item&gt;</code></pre><p><strong>效果</strong></p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/202305241609134.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>项目目前稳定跑了一段时间了，没有出现过什么问题，但是实现的过程并不是那么的顺利，要实现一个完整的业务系统，我相信上面的需求是最基本的。</p><p>还有一些权限的修改，让页面可以支持权限显示和隐藏一些功能，在这之前只能控制的只有数据。以及增加快速录入数据的页面 等等 这其中代码中关联了公司业务，所以这里就不贴出来了。</p><p>之前看过 illacloud ，但是这个东西并不那么简单，要实现一个完整业务系统可能比较困难，我最在意的 ui 特别丑，无法调试，比如一个菜单放上去 就那个样式了，无法调整字体大小，边框 菜单背景 等等。</p><p>illacloud 这种可能更适合单个页面快速的展示一些数据，页面之间是无状态的，功能比较强大，还支持训练业务数据然后进行提问，类似 chatgpt。</p><p>很感谢 yao 开源项目，让我了解低代码引擎的实现原理，以及实现过程中可能出现的问题。开源项目文档很重要，如果这种方式 DSL 学习成本低一点，文档完善一点，基础功能稳定一点，我是最愿意去使用的。</p><p>比如这里的一些自带的处理器</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog202305242241921.png"></p><p>这些处理器都是找不到的，因为处理器名称后面修改了，文档并没有同步</p><pre><code class="go">gou.AliasProcess(&quot;xiang.main.Ping&quot;, &quot;utils.app.Ping&quot;)gou.AliasProcess(&quot;xiang.main.Inspect&quot;, &quot;utils.app.Inspect&quot;)// FMTgou.AliasProcess(&quot;xiang.helper.Print&quot;, &quot;utils.fmt.Print&quot;)// ENVgou.AliasProcess(&quot;xiang.helper.EnvSet&quot;, &quot;utils.env.Get&quot;)gou.AliasProcess(&quot;xiang.helper.EnvGet&quot;, &quot;utils.env.Get&quot;)gou.AliasProcess(&quot;xiang.helper.EnvMultiSet&quot;, &quot;utils.env.SetMany&quot;)gou.AliasProcess(&quot;xiang.helper.EnvMultiGet&quot;, &quot;utils.env.GetMany&quot;)// Flowgou.AliasProcess(&quot;xiang.helper.For&quot;, &quot;utils.flow.For&quot;)gou.AliasProcess(&quot;xiang.helper.Each&quot;, &quot;utils.flow.Each&quot;)gou.AliasProcess(&quot;xiang.helper.Case&quot;, &quot;utils.flow.Case&quot;)gou.AliasProcess(&quot;xiang.helper.IF&quot;, &quot;utils.flow.IF&quot;)gou.AliasProcess(&quot;xiang.helper.Throw&quot;, &quot;utils.flow.Throw&quot;)gou.AliasProcess(&quot;xiang.helper.Return&quot;, &quot;utils.flow.Return&quot;)// JWTgou.AliasProcess(&quot;xiang.helper.JwtMake&quot;, &quot;utils.jwt.Make&quot;)gou.AliasProcess(&quot;xiang.helper.JwtValidate&quot;, &quot;utils.jwt.Verify&quot;)</code></pre><p>yao 的实现思路我觉得比较好，扩展性很强，但是基础服务并没有那么多好用。比如数据导出的自定义处理器无法获取到查询参数，现在导出只能全部导出。另外关于页面多次触发点击的问题，这个我目前没有时间去改了 暂时先这样用吧。</p><p>接下来的后续就是，我是给自己找事情干来着，后期计划还是先自己实现，yao 引擎的数据库可以直接用，因为是底层是 xorm，所以还是比较简单扩展。<br>这次并没有节约我的时间，相反 花的时间更多了，从面向代码编程变成了面向 DSL 编程。收获并不是没有，但是不多。</p><p>下一次低代码平台我会选择腾讯微搭。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Krpano 全景播放初探</title>
      <link href="/2018/05/22/Krpano/"/>
      <url>/2018/05/22/Krpano/</url>
      
        <content type="html"><![CDATA[<p>Krpano 是一套全景解决方案 支持视频以及图片  也是商业化项目使用最多的全景播放器 不过它并不免费 其特点是在支持 HTML5 模式中 采用 WebGL 以及 CSS3D 实现 在不支持 HTML5 标准的浏览器中 可以使用 Flash 实现，而对于我们来说不需要关心 HTML5 和 Flash 的实现，成本就是需要学习 Krpano 的 DSL 语法 。</p><p>Krpano 的 DSL 语法类似 XML，它有完整的生态(插件机制)以及 Demo，也可以使用原生 JS 调用 Krpano 的 SDK  所以上手并不是特别困难 在这里我主要说下 Krpano 插件的解密、添加对于腾讯 X5 内核的支持以及各个浏览器的支持情况。</p><span id="more"></span><h2 id="插件解密"><a href="#插件解密" class="headerlink" title="插件解密"></a>插件解密</h2><p>krpano 几乎所有的 JS 都是经过混淆和加密处理 ，不过既然是 JS 就没有绝对的加密 具体可以了解下 </p><blockquote><p> [<a href="https://www.zhihu.com/question/28468459/answer/41622094]">https://www.zhihu.com/question/28468459/answer/41622094]</a> 来自知乎的回答</p></blockquote><p>先来看下 Krpano 的文件列表</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/6iarqw.jpg"></p><p>插件路径位于 <code>viewer/plugins</code> 下, 这次就拿 webvr.js 来解密。</p><p>先来看看正常打开 webvr.js 是什么 </p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/y0fjz5.jpg"></p><p>如图所示，在经过测试后发现 这段代码并不能通过常用的方式解密，在仔细观察插件 webvr.js 文件 几乎所有都是引号开头的 也就是说这是一窜字符串密文   这让我想起了 <code>eval</code> 函数 。<br>在浏览器中直接执行 eval</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/57i2co.jpg"></p><p>虽然失败了 但是能发现丢失了一个括号，可能还缺少一些依赖字符串 ，浏览器端要执行这段代码 Krpano 一定会有解密的过程  ，所以看了下 <code>krpano.js</code></p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/zx4sf4.jpg"></p><p>看起来是混淆加密，解密之后得到<br><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/9dvs7o.jpg"></p><p>尽管部分代码还是被混淆了 不过也不会影响查找 eval 函数 。 </p><p>找到如下关键代码：</p><pre><code class="js">eval(function(f) &#123;            var q = String.fromCharCode              , n = 1              , k = f.length              , b = null              , e = null              , a = 0              , d = 0              , m = 0              , c = 0              , h = 0              , l = 0              , g = 0;            try &#123;                q.apply(null, (new Uint8Array(4)).subarray(2))            &#125; catch (p) &#123;                n = 0            &#125;            e = n ? Uint8Array : Array;            for (b = new e(4 * k / 5); a &lt; k; )                m = f.charCodeAt(a) - 35,                c = f.charCodeAt(a + 1) - 35,                h = f.charCodeAt(a + 2) - 35,                l = f.charCodeAt(a + 3) - 35,                g = f.charCodeAt(a + 4) - 35,                g = 85 * (85 * (85 * (85 * (m - (56 &lt; m | 0)) + (c - (56 &lt; c | 0))) + (h - (56 &lt; h | 0))) + (l - (56 &lt; l | 0))) + (g - (56 &lt; g | 0)),                b[d] = g &gt;&gt; 24 &amp; 255,                b[d + 1] = g &gt;&gt; 16 &amp; 255,                b[d + 2] = g &gt;&gt; 8 &amp; 255,                b[d + 3] = g &amp; 255,                a += 5,                d += 4;            e = new e(b[2] &lt;&lt; 16 | b[1] &lt;&lt; 8 | b[0]);            k = 8 + (b[6] &lt;&lt; 16 | b[5] &lt;&lt; 8 | b[4]);            a = 8;            for (d = 0; a &lt; k; ) &#123;                m = b[a++];                c = m &gt;&gt; 4;                for (h = c + 240; 255 === h; c += h = b[a++])                    ;                for (l = a + c; a &lt; l; )                    e[d++] = b[a++];                if (a === k)                    break;                g = d - (b[a++] | b[a++] &lt;&lt; 8);                c = m &amp; 15;                for (h = c + 240; 255 === h; c += h = b[a++])                    ;                for (l = d + c + 4; d &lt; l; )                    e[d++] = e[g++]            &#125;            b.length = 0;            k = e.length;            if (n &amp;&amp; window.TextDecoder)                return (new TextDecoder).decode(e);            a = 0;            for (f = &quot;&quot;; a &lt; k; a += 32E3)                f += q.apply(null, n ? e.subarray(a, a + 32E3) : e.slice(a, a + 32E3));            return f        &#125;(&#39;.....&#39;))</code></pre><p>能看出这是一段 eval 的闭包 ，由于后面的代码太长 这里就省略了 ，开始以为这就是 eval 解析的地方 我尝试把 webvr.js 的代码贴在闭包后面 不过出错了：</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/77thcf.jpg"></p><p>执行完毕之后 发现了一段 embedpano 函数，那么经过解密 中间的 eval 变成了这个函数 在结合之前有一段代码：</p><pre><code class="js">  embedpano(p, &quot;krp:DIFE91v=AhGY8PB&#125;wruuSq(LUNDcJB+.o/j%EK-F^-@NMK17knoYef6U_/+X?/r5:s@0i%vj7H&#125;?_zebl=`r&#123;fxnz.$xV%1_hQHLiUqmFf.....&#39;)</code></pre><p>基本能确定 这里就是解密的关键，经过查找在 embedpano 中找到了 eval 函数:</p><pre><code class="js">function n(a, c, b) &#123;    var krpano = l;    var caller = b;    var args = c;    var resolve = B;    var actions = k;    try &#123;       console.log(a)       console.log(b)        eval(a, b)    &#125; catch (d) &#123;        oa(3, c[0] + &quot; - &quot; + d)    &#125;&#125;</code></pre><p>如上所示，只需要添加一个 console 把最终执行的字符串打印出来 就是插件源码了：<br><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/o4fatp.jpg"></p><p>能看到段落中的就是插件源码 之所以有两个是因为这个页面加载了两个插件 根据关键字 webvr 就能够找到你需要的插件源码  。</p><p>上面就是 Krpano 的解密过程 ，版本为：krpano-1.19-pr15</p><p>解密后的 krpano.js <a href="https://gist.github.com/yumexupanic/63be826c78f208309a9378c44a5bfe64">https://gist.github.com/yumexupanic/63be826c78f208309a9378c44a5bfe64</a></p><p>解密后的 webvr.js <a href="https://gist.github.com/yumexupanic/ca27d1e4e33c02a9bb5a800b4b106c93">https://gist.github.com/yumexupanic/ca27d1e4e33c02a9bb5a800b4b106c93</a></p><h2 id="X5-内核支持"><a href="#X5-内核支持" class="headerlink" title="X5 内核支持"></a>X5 内核支持</h2><p>说明一下  X5 内核只会出现在 Andorid 平台 ，IOS 由于系统的限制必须使用苹果的 WebKit 内核，所以 IOS 上的微信以及 QQ 浏览器 并不是 X5 内核。</p><p>Krpano 默认生成的全景视频播放器 是无法在微信浏览器 和 QQ 浏览器中正常访问的，全景图片可以正常使用 。这是因为 X5 内核的限制 所有的视频都会被拦截，拦截具体的表现就是只要页面有使用 video 标签或者是 JS 动态创建了 video 标签 在点击播放时(或者触发时) 会使用 native 组件进行播放 并拦截视频。由于全景视频几乎使用 Canvas 实现 监听的事件都不会被触发 因为本身 video 没有播放 只是组件播放而已。</p><p>这个问题在 X5 内核版本 &gt; 036849 中解决了，因为引入了一个重要的元素： </p><pre><code class="html">&lt;video src=&quot;...&quot;x5-video-player-type=&quot;h5&quot;&gt;&lt;/video&gt;</code></pre><p>这个元素意思是使用 HTML5 的播放器 不拦截视频，如果你是 JS 动态创建的 video ，那么加上这个属性就可以了</p><pre><code>var video = document.createElement(&#39;video&#39;);video.src=&#39;...&#39;;video.setAttribute(&#39;x5-video-player-type&#39;,&#39;h5&#39;);</code></pre><p>那么结合上面的插件解密的教程 我们就可以更改 Krpano 的 <code>videoplayer.js</code> 插件源码:</p><pre><code class="js">    function ca() &#123;        var a = null,            a = document.createElement(&quot;video&quot;);            a.setAttribute(&quot;x5-video-player-type&quot;,&quot;h5&quot;);        if (!a || !a.play) return null;        ba(a);        return a    &#125;</code></pre><p>如果不想使用这种方式 可以使用 Krpano 提供的 开源 video.js 详情： <a href="https://krpano.com/plugins/videoplayer/#source">https://krpano.com/plugins/videoplayer/#source</a> 同样 找到 video 标签来进行修改。</p><p>修改成功后 直接使用微信访问 (如果没有生效 尝试清楚下微信的缓存)<br>这种方式只适用于安卓的 X5 内核浏览器，IOS 并不生效。</p><h3 id="有声音没画面"><a href="#有声音没画面" class="headerlink" title="有声音没画面"></a>有声音没画面</h3><p>还是单独说下这个问题，具体表现就是在个别浏览器中 (搜狗) 点击播放后 看不见全景画面 但可以听到视频声音。</p><p>这个问题我查了很多资料 最后总结是 浏览器问题 暂时无法解决。</p><p>不过可以了解下原因，最开始出现的浏览器是 chromeium 内核版本为 43.0.2357.78 </p><p>相关bug:<br><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=494620">https://bugs.chromium.org/p/chromium/issues/detail?id=494620</a><br><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=485482">https://bugs.chromium.org/p/chromium/issues/detail?id=485482</a></p><p>调用 WebGL 播放视频 这个 Bug 就能重现 ，这是一个很简单的例子：<a href="http://krpano.com/android/chrome-43-black-video-webgl/">http://krpano.com/android/chrome-43-black-video-webgl/</a></p><p>这种 Bug 只会出现在 Android 平台 随便附上一个 chrome 历史版本下载的网站<br><a href="https://www.apkmirror.com/apk/google-inc/chrome-beta/chrome-beta-43-0-2357-78-release/chrome-beta-43-0-2357-78-arm64-android-apk-download/download">https://www.apkmirror.com/apk/google-inc/chrome-beta/chrome-beta-43-0-2357-78-release/chrome-beta-43-0-2357-78-arm64-android-apk-download/download</a></p><p>有兴趣可以测试下。</p><h3 id="视频被劫持"><a href="#视频被劫持" class="headerlink" title="视频被劫持"></a>视频被劫持</h3><p>除开 Android 平台能解决的劫持问题外，IOS 的 QQ 浏览器以及 UC 浏览器暂时无法解决。<br>不过能确定的是 它们两家都是有白名单模式的 可以访问 bilibili.com 或者 aibo.3q.qq.com 后面这个是腾讯自家的产品 不会被拦截 为了证实这个想法 我尝试把本地的 DNS  aibo.3q.qq.com 指向了 127.0.0.1 结果发现是可以正常播放全景视频的，但并没找到白名单相关入口。</p><h2 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h2><p>做了一个测试列表，主要是查看几款开源的全景视频和 Krpano 在不同平台以及浏览器的支持。</p><p>全景视频播放器：Krpano、insta360、marzipano、pannellum</p><p>Android： Chrome、Firefox、微信浏览器、QQ 浏览器、360<br>IOS：Chrome、Firefox、 微信浏览器、QQ 浏览器、360、Safari</p><table><thead><tr><th>平台</th><th>浏览器</th><th>浏览器版本</th><th>内核版本</th><th>krpano 全景支持</th><th>insta360 全景支持</th><th>marzipano 全景支持</th><th>pannellum 全景支持</th></tr></thead><tbody><tr><td>Android</td><td>Chrome</td><td>63.0.3239.111</td><td>Chromeium 63.0.3239.111</td><td>支持</td><td>不支持(普通视频)</td><td>支持</td><td>支持</td></tr><tr><td>Firefox</td><td>59.0.2</td><td>Gecko (Firefox 59)</td><td>支持</td><td>不支持(普通视频)</td><td>支持</td><td>不支持(普通视频)</td><td></td></tr><tr><td>微信浏览器</td><td>6.6.6</td><td>腾讯 X5 043906</td><td>支持</td><td>不支持(普通视频)</td><td>不支持(视频劫持)</td><td>不支持(提示需要 WebGl)</td><td></td></tr><tr><td>搜狗浏览器</td><td>5.12.12.45171</td><td>Chromeium 56.0.2924.116</td><td>不支持(黑屏)</td><td>不支持(普通视频)</td><td>不支持(无画面)</td><td>不支持(提示需要 WebGl)</td><td></td></tr><tr><td>QQ 浏览器</td><td>8.3.1.4075</td><td>腾讯 X5 038370</td><td>支持</td><td>不支持(普通视频)</td><td>不支持(无画面)</td><td>不支持(普通视频)</td><td></td></tr><tr><td>UC 浏览器</td><td>V11.9.6.976</td><td>Chromeium 57.0.2987.108</td><td>不支持(无画面)</td><td>不支持(普通视频)</td><td>不支持(无画面)</td><td>不支持(无画面)</td><td></td></tr><tr><td>360 浏览器</td><td>8.2.0.120</td><td>Chromeium 62.0.3202.97</td><td>支持</td><td>不支持(普通视频)</td><td>支持</td><td>支持</td><td></td></tr><tr><td>百度浏览器</td><td>7.18</td><td>Chromeium 48.0.2564.116</td><td>不支持(无画面)</td><td>不支持(普通视频)</td><td>不支持(无画面)</td><td>不支持(提示需要 WebGl)</td><td></td></tr><tr><td>iPhone</td><td>Chrome</td><td>66.0.3359.122</td><td>Webkit 604.1.34</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Firefox</td><td>11.1</td><td>Webkit 604.5.6</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>Safari</td><td>未知</td><td>Webkit 604.5.6</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>微信浏览器</td><td>6.6.6</td><td>Webkit 604.5.6</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>搜狗浏览器</td><td>5.11.10</td><td>Webkit 604.5.6</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>QQ 浏览器</td><td>8.4.0.3851</td><td>Webkit 604.3.6</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td></td></tr><tr><td>UC 浏览器</td><td>V11.9.4.1067</td><td>Webkit 537.51.1</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td>不支持(视频劫持)</td><td></td></tr><tr><td>360 浏览器</td><td>4.0.9</td><td>Webkit 604.5.6</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>百度浏览器</td><td>4.13.0</td><td>Webkit 604.5.6</td><td>不支持(无画面)</td><td>不支持(无画面)</td><td>不支持(无画面)</td><td>不支持(无画面)</td><td></td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>附上两枚 Krpano 激活码（仅供学习）</p><p>FXsqTqaGNSZER5dSETEm+VzQEh9sWSa5DZMFsSmMxYV9GcXs8W3R8A&#x2F;mWXrGNUceXvrihmh28hfRF1ivrW0HMzEychPvNiD8B&#x2F;4&#x2F;ZzDaUE9Rh6Ig22aKJGDbja1&#x2F;kYIqmc&#x2F;VKfItRE2RTSOIbIroxOtsz626NIpxWksAAifwhpNwuPXqDQpz2sRUMBzoPqZktpkItoSenN2mKd8Klfx7pOuB6CIK3e1CDXgyndqOt2mWybLZcU&#x2F;wfJVAecfxk15ghiqrzaDsbqrdABDowg&#x3D;&#x3D;</p><p>ruza4tk2X4MdHuE7djJQGr9QTftMFHiSH2ac5jkIlFgGqG0K0IVQnh5vF&#x2F;cicLpwedsURI0QTg+UluEgysRLUytpeVFyBTxdwREEIGquRh1Hp2BY2EtZ8kdO2r6CHLJAFlzY5w6au1rnHwRhJXgaK8J75RwK1DYb&#x2F;OEZ4tD2pniUrnMrpFwGWwcKnxGyNSmMktsU6qadFjKbMH3HUKNXa7Y59lEzbDZJbsTuP+UynwwBhogv8K+byjs2LDvU48sx4&#x2F;CNHWi26g&#x3D;&#x3D;</p><p>Krpano 有提供 CLI 工具来生成全景播放  具体可以参考文档：<a href="https://krpano.com/tools/kmakemultires/config/#xmltemplate_hotspot">https://krpano.com/tools/kmakemultires/config/#xmltemplate_hotspot</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github.la 域名购买记</title>
      <link href="/2017/01/15/github-la/"/>
      <url>/2017/01/15/github-la/</url>
      
        <content type="html"><![CDATA[<p>为什么我会入手一款非主流域名？完全是因为最近的微信小程序 (Lite App) 的概念，在腾讯云购买服务器的时候看见他们家正在安利 .la 域名</p><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/obsa00.jpg"></p><p>去网上查了查 .la 域名没有投资的价值 不过作为网站域名还是挺好玩的 (啦的拼音嘛)</p><span id="more"></span><h2 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h2><p>去看了看 xiaochengxu.la,早在16年9月22号被神秘人注册, 我随便输入了一个 github ，搜索结果除开中文后缀 和 .la 没有被人注册 其它的都被注册了 我想了想 正好小程序出来了 干脆就买了 要是卖出去了呢？？？ 在腾讯买的话需要 300 大洋一年，太贵了！！</p><p>我去西部数码看了看 ，只需要 86 元一年，于是就有了:<br><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/k7bgei.jpg"></p><h2 id="字体渲染方案"><a href="#字体渲染方案" class="headerlink" title="字体渲染方案"></a>字体渲染方案</h2><p>大家是不是觉得上面的中文字体很漂亮？因为我使用了 Google 的 Noto 字体库。</p><p>因为 css3 的原因 让我们的网页引入外部字体成为可能，按照以前的方法 只能引入操作系统的内部字体 还得考虑到兼容性的问题，所以能看到这样的 css</p><pre><code class="css">html,body &#123;    font-family: &quot;Helvetica Neue&quot;,Helvetica, Arial, sans-serif;    ...&#125;</code></pre><p>有了外部字体的支持 ，我们只需要这样写</p><pre><code class="css">/*声明 WebFont*/@font-face &#123;  font-family: &#39;pinghei&#39;;  src: url(&#39;../font/pinghei.eot&#39;);  src:    url(&#39;../font/pinghei.eot?#font-spider&#39;) format(&#39;embedded-opentype&#39;),    url(&#39;../font/pinghei.woff&#39;) format(&#39;woff&#39;),    url(&#39;../font/pinghei.ttf&#39;) format(&#39;truetype&#39;),    url(&#39;../font/pinghei.svg&#39;) format(&#39;svg&#39;);  font-weight: normal;  font-style: normal;&#125;/*使用选择器指定字体*/html,body &#123;    font-family: &#39;pinghei&#39;;&#125;</code></pre><p>虽然能够引入外部字体，但对于中文的支持却没有那么好，因为英文就只有 26 个英文单词进行组合，所以字体库非常的小。但是中文汉字博大精深,不是几个组合就能解决的了,所以字体库也达到了 18M 左右，你总不会让你的用户访问一下页面就下载 18M 的文件吧。有没有一种可能只使用网页出现的中文台字体呢？一个网页毕竟是用的中文文字就那几个。如果我们去掉没有使用过的中文字体 不就可以了？<br>我查了一下找到了这个：<a href="https://github.com/aui/font-spider/">https://github.com/aui/font-spider/</a> 字蛛，让网页自由引入中文字体成为可能。</p><blockquote><p>github.la 上面的中文字体库只有 4kb</p></blockquote><h2 id="使用-LeanCode-来做我的数据统计"><a href="#使用-LeanCode-来做我的数据统计" class="headerlink" title="使用 LeanCode 来做我的数据统计"></a>使用 LeanCode 来做我的数据统计</h2><pre><code class="js">买了域名不折腾浑身痒啊！我想统计下有多少人对这个域名有兴趣，但是又没有联系我 ，所以使用了 BaaS 服务// 应用 ID，用来识别应用var APP_ID = &#39;NE6l6escz3DCjNH4qYxhUtzx-gzGzoHsz&#39;;// 应用 Key，用来校验权限（Web 端可以配置安全域名来保护数据安全）var APP_KEY = &#39;cPrqfRLYe2nfa72BMbtBsB0E&#39;;// 初始化AV.init(&#123;  appId: APP_ID,  appKey: APP_KEY&#125;);var count = AV.Object.extend(&#39;Count&#39;);var countImpl = new count();var data = &#123;title: &#39;访问 Github.la&#39;,url: location.href&#125;;data = Object.assign(data,returnCitySN);countImpl.save(data).then(function()&#123;    console.log(&#39;successful.&#39;);&#125;).catch(function(err)&#123;    console.log(&#39;error:&#39; + err);&#125;)</code></pre><p><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/yaup4u.jpg"></p><h2 id="使用-Qpush-来做实时推送"><a href="#使用-Qpush-来做实时推送" class="headerlink" title="使用 Qpush 来做实时推送"></a>使用 Qpush 来做实时推送</h2><p>我还希望有人访问这个页面的时候，自动通知道到我的手机，所以找了大半天，终于找打一个能够通过网页手动推送消息的 APP Qpush<br><img src="https://imgur-cloud.oss-cn-chengdu.aliyuncs.com/blog/qdfdtg.jpg"></p><pre><code class="js">var msg = &#39;有人对你的域名有兴趣，是来自&#39; + returnCitySN.cname + &#39;的小伙伴,ip:&#39; + returnCitySN.cip;var pushData = &#123;name: &#39;Duai&#39;,code: 238099,cache: true,&#39;msg[text]&#39;: msg&#125;$.post(&#39;https://qpush.me/pusher/push_site/&#39;,pushData)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个域名应该不会有人买吧，挂一段时间我就自己用。</p><p><a href="https://zh.wikipedia.org/zh-tw/.la">https://zh.wikipedia.org/zh-tw/.la</a></p><h2 id="2023-05-03-11-25-10-更新"><a href="#2023-05-03-11-25-10-更新" class="headerlink" title="2023.05.03 11:25:10 更新"></a>2023.05.03 11:25:10 更新</h2><p>过了这么久了啊，这个域名早已经没有在我手上了，大概持有了2年就没续费了。现在也不知道被谁买走了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
